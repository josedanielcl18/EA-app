<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All Predictions & Results - EA Predictor</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/styles2.css">
</head>
<body class="bg-dark text-white">

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="index.html">EA Predictor</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link" href="index.html">Predictions</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="tabla.html">All Results & Predictions <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="game_weeks.html">Game Weeks <span class="sr-only">(current)</span></a>
                </li>
            </ul>
        </div>
    </nav>


    <div class="container py-4">
        <h1 class="text-center mb-5">All Game Results & Predictions</h1>

        <div id="overall-leaderboard-container" class="game-results-card mb-5" style="display: none;">
            <h2 class="text-center mb-4">Overall Player Standings</h2>
            <div id="leaderboard-list">
                <p class="text-center text-muted">Calculating overall scores...</p>
            </div>
        </div>
        <div id="all-games-results-container">
            <p class="text-center text-muted">Loading game results and predictions...</p>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, orderBy, where } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

        // Your Firebase project configuration
        const firebaseConfig = {
        apiKey: "AIzaSyDLfJ01cou9x4dBIirKbb016a69phKXOPc",
        authDomain: "ea-football-predictor.firebaseapp.com",
        projectId: "ea-football-predictor",
        storageBucket: "ea-football-predictor.firebasestorage.app",
        messagingSenderId: "419246128197",
        appId: "1:419246128197:web:3082ec10e3e4e81432b72c"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // UI Elements
        const allGamesResultsContainer = document.getElementById('all-games-results-container');
        const overallLeaderboardContainer = document.getElementById('overall-leaderboard-container');
        const leaderboardList = document.getElementById('leaderboard-list');

        // --- Scoring Logic ---
        function calculatePoints(prediction, game) {
            // 1. Initial Checks:
            if (game.Status !== 'finished' || game.HomeScore === null || game.AwayScore === null) {
                return null; // Game not finished or actual scores not available
            }

            const predictedHome = prediction.predictedHomeScore;
            const predictedAway = prediction.predictedAwayScore;
            const actualHome = game.HomeScore;
            const actualAway = game.AwayScore;

            if (predictedHome === null || predictedAway === null) {
                return 0; // No valid prediction entered for this game
            }

            let points = 0;

            // Determine outcomes
            const predictedOutcome = predictedHome > predictedAway ? 'HW' : (predictedHome < predictedAway ? 'AW' : 'D');
            const actualOutcome = actualHome > actualAway ? 'HW' : (actualHome < actualAway ? 'AW' : 'D');

            // Determine goal differences
            const predictedGoalDifference = predictedHome - predictedAway;
            const actualGoalDifference = actualHome - actualAway;

            // --- Apply Scoring Rules ---

            // 1. Correct Winner/Draw (Outcome): +5 points
            if (predictedOutcome === actualOutcome) {
                points += 5;
            }

            // 2. Correct Home Team Goals: +2 points
            if (predictedHome === actualHome) {
                points += 2;
            }

            // 3. Correct Away Team Goals: +2 points
            if (predictedAway === actualAway) {
                points += 2;
            }

            // 4. Correct Goal Difference (absolute value): +1 point
            // This condition applies regardless of win/loss direction, just the margin.
            // E.g., predicted 1-2 (diff -1), actual 2-1 (diff 1). Abs diff is 1 for both.
            if (Math.abs(predictedGoalDifference) === Math.abs(actualGoalDifference)) {
                points += 1;
            }

            return points;
        }

        // --- Load All Results Function ---
        async function loadAllResults() {
            allGamesResultsContainer.innerHTML = '<p class="text-center text-muted">Loading game results and predictions...</p>';

            try {
                // 1. Fetch all games
                const gamesSnapshot = await getDocs(query(collection(db, 'games'), orderBy('KickOffTime', 'desc')));
                const games = {};
                gamesSnapshot.forEach(doc => {
                    games[doc.id] = { id: doc.id, ...doc.data(), predictions: [] };
                });

                // 2. Fetch all predictions
                const predictionsSnapshot = await getDocs(query(collection(db, 'predictions'), orderBy('timestamp', 'desc')));
                predictionsSnapshot.forEach(doc => {
                    const prediction = doc.data();
                    if (games[prediction.gameId]) {
                        games[prediction.gameId].predictions.push(prediction);
                    }
                });

                // --- Calculate Overall Player Stats (Points, Fechas Won, Perfect Scores) ---
                const playerStats = {}; // Stores { totalPoints, fechasWonCount, perfectScoresCount }
                const fechaScores = {}; // To store scores per player per Fecha
                const userNames = {};   // { userId: latestPlayerName }

                // Initialize playerStats for all players who have made at least one prediction
                // This ensures players with 0 points but perhaps some Fecha wins or 10s are still tracked
                predictionsSnapshot.forEach(doc => {
                    const data = doc.data();
                    const userId = data.userId || 'unknown';
                    const playerName = data.playerName || 'Anonymous';

                    if (!playerStats[userId]) {
                        playerStats[userId] = {
                            totalPoints: 0,
                            fechasWonCount: 0,
                            perfectScoresCount: 0
                        };
                    }

                    // Always update the "latest" name
                    userNames[userId] = playerName;
                });

                for (const gameId in games) {
                    const game = games[gameId];
                    const fecha = game.Fecha; // Get the Fecha field

                    if (!fecha) {
                        // console.warn(`Game ${game.id} (${game.HomeTeam} vs ${game.AwayTeam}) has no 'Fecha' field. Skipping Fecha bonus calculation for this game.`);
                        // Continue processing this game for regular points, just skip Fecha-specific logic for it.
                    }

                    // Temporarily store max score for each player for the current Fecha
                    if (fecha && !fechaScores[fecha]) {
                        fechaScores[fecha] = {};
                    }

                    game.predictions.forEach(prediction => {
                        const userId = prediction.userId || 'unknown';
                        const playerName = prediction.playerName || 'Anonymous';
                        const points = calculatePoints(prediction, game);

                        userNames[userId] = playerName; // keep the latest name

                        if (points !== null) { // Only count points if the game is finished and points were calculated
                            // Ensure playerStats entry exists (it should, due to initialization, but good for safety)
                            if (!playerStats[userId]) {
                                playerStats[userId] = {
                                    totalPoints: 0,
                                    fechasWonCount: 0,
                                    perfectScoresCount: 0
                                };
                            }

                            // Add to overall total points
                            playerStats[userId].totalPoints += points;

                            // Add to Fecha score (for determining Fecha winners later)
                            if (fecha) { // Only if Fecha is defined
                                if (!fechaScores[fecha][userId]) {
                                    fechaScores[fecha][userId] = 0;
                                }
                                fechaScores[fecha][userId] += points;
                            }

                            // Count perfect scores
                            if (points === 10) {
                                playerStats[userId].perfectScoresCount += 1;
                            }
                        }
                    });
                }

                // --- Fecha Wins ---
                for (const fecha in fechaScores) {
                    const playersInFecha = fechaScores[fecha];
                    if (Object.keys(playersInFecha).length === 0) continue;

                    let maxFechaScore = Math.max(...Object.values(playersInFecha));
                    const fechaWinners = Object.keys(playersInFecha)
                        .filter(userId => playersInFecha[userId] === maxFechaScore);

                    fechaWinners.forEach(userId => {
                        if (playerStats[userId]) {
                            playerStats[userId].fechasWonCount += 1;
                        }
                    });
                }

                // --- Render the overall leaderboard ---
                renderLeaderboard(playerStats, userNames); // Pass the detailed playerStats object

                // 3. Render the individual game results
                allGamesResultsContainer.innerHTML = ''; // Clear loading message

                if (Object.keys(games).length === 0) {
                    allGamesResultsContainer.innerHTML = '<p class="text-center">No games found.</p>';
                    return;
                }

                // Convert games object to array and sort by KickOffTime for display
                const sortedGamesArray = Object.values(games).sort((a, b) => {
                    // Ensure KickOffTime is a Date object for comparison if it's a Firestore Timestamp
                    const dateA = a.KickOffTime.toDate ? a.KickOffTime.toDate() : new Date(a.KickOffTime);
                    const dateB = b.KickOffTime.toDate ? b.KickOffTime.toDate() : new Date(b.KickOffTime);
                    return dateB - dateA;
                });

                for (const game of sortedGamesArray) { // Iterate over sorted array
                    const gameCard = document.createElement('div');
                    gameCard.classList.add('game-results-card', 'app-card');

                    const actualResultDisplay = (game.Status === 'finished' || game.Status === 'live') && game.HomeScore !== null && game.AwayScore !== null
                        ? `<p class="actual-result">Actual Result: ${game.HomeScore} - ${game.AwayScore}</p>`
                        : `<p class="actual-result">Actual Result: Not available yet</p>`;


                    gameCard.innerHTML = `
                        <h3 class="game-header">
                            ${game.HomeTeam} vs ${game.AwayTeam}
                            <span class="game-status ${game.Status}">${game.Status.toUpperCase()}</span>
                        </h3>
                        <p class="game-info">${game.League} - ${new Date(game.KickOffTime).toLocaleString([], { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric' })}</p>
                        ${game.Fecha ? `<p class="game-info">Fecha: ${game.Fecha}</p>` : ''} ${actualResultDisplay}
                        <hr>
                        <h4 class="mb-3">All Predictions:</h4>
                        <div class="predictions-list">
                            ${
                                // OUTER TERNARY: Is the game finished or live?
                                game.Status === 'finished' || game.Status === 'live'
                                    ? // IF TRUE (game is finished or live):
                                      // INNER TERNARY: Are there any predictions for this game?
                                      (game.predictions.length > 0
                                        ? game.predictions.map(prediction => {
                                            const points = calculatePoints(prediction, game);
                                            let pointsDisplay = '';
                                            let pointsClass = 'text-muted';

                                            if (points === null) {
                                                pointsDisplay = 'N/A';
                                                pointsClass = 'text-muted';
                                            } else if (points === 10) {
                                                pointsDisplay = `(${points} points - Perfect Score!)`;
                                                pointsClass = 'text-success';
                                            } else if (points >= 5) {
                                                pointsDisplay = `(${points} points)`;
                                                pointsClass = 'text-info';
                                            } else if (points > 0) {
                                                pointsDisplay = `(${points} points)`;
                                                pointsClass = 'text-warning';
                                            } else { // 0 points
                                                pointsDisplay = `(${points} points)`;
                                                pointsClass = 'text-danger';
                                            }

                                            return `
                                                <div class="prediction-entry">
                                                    <span><strong>${prediction.playerName || 'Anonymous'}</strong> predicted: ${prediction.predictedHomeScore} - ${prediction.predictedAwayScore}</span>
                                                    <span class="score ${pointsClass}">${pointsDisplay}</span>
                                                </div>
                                            `;
                                        }).join('') // .map() ends here
                                        : '<p class="text-muted">No predictions submitted for this game yet.</p>'
                                      ) // <--- CRUCIAL: This closes the parentheses for the "true" part of the INNER ternary.
                                    : // ELSE (game is NOT finished or live - meaning it's upcoming, etc.):
                                    '<p class="text-muted">Predictions are hidden until the game is finished.</p>'
                            }
                        </div>
                    `;
                    allGamesResultsContainer.appendChild(gameCard);
                }

            } catch (error) {
                console.error("Error loading all results: ", error);
                allGamesResultsContainer.innerHTML = '<p class="text-center" style="color: red;">Error loading results. Please try again later.</p>';
            }
        }

        // --- Render Overall Leaderboard ---
        function renderLeaderboard(playerStats, userNames) { // Now accepts playerStats object
            leaderboardList.innerHTML = ''; // Clear previous content
            overallLeaderboardContainer.style.display = 'block'; // Make leaderboard visible

            // Convert playerStats object into an array of [playerName, statsObject] pairs
            // Then sort based on the new criteria
            const sortedPlayers = Object.entries(playerStats).sort(([idA, statsA], [idB, statsB]) => {
                if (statsB.totalPoints !== statsA.totalPoints) {
                    return statsB.totalPoints - statsA.totalPoints;
                }
                if (statsB.fechasWonCount !== statsA.fechasWonCount) {
                    return statsB.fechasWonCount - statsA.fechasWonCount;
                }
                if (statsB.perfectScoresCount !== statsA.perfectScoresCount) {
                    return statsB.perfectScoresCount - statsA.perfectScoresCount;
                }
                return (userNames[idA] || '').localeCompare(userNames[idB] || '');
            });


            if (sortedPlayers.length === 0) {
                leaderboardList.innerHTML = '<p class="text-center text-muted">No total scores to display yet.</p>';
                return;
            }

            // Create a table for a nicer display with columns
            const table = document.createElement('table');
            table.classList.add('table', 'table-dark', 'table-striped', 'table-hover'); // Bootstrap table classes

            table.innerHTML = `
                <thead>
                    <tr>
                        <th scope="col">#</th>
                        <th scope="col">Player</th>
                        <th scope="col">Points</th>
                        <th scope="col" class="text-center">Fechas Won</th>
                        <th scope="col" class="text-center">Perfect Scores (10s)</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;

            const tbody = table.querySelector('tbody');

            sortedPlayers.forEach(([userId, stats], index) => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <th scope="row">${index + 1}</th>
                    <td><strong>${userNames[userId] || 'Anonymous'}</strong></td>
                    <td><span class="badge badge-light badge-pill">${stats.totalPoints}</span></td>
                    <td class="text-center"><span class="badge badge-info">${stats.fechasWonCount}</span></td>
                    <td class="text-center"><span class="badge badge-warning">${stats.perfectScoresCount}</span></td>
                `;
            });

            leaderboardList.appendChild(table);
        }

        // Call the function when the page loads
        document.addEventListener('DOMContentLoaded', loadAllResults);
    </script>
</body>
</html>